그래프 이론

1. 서로소 집합 알고리즘(A,B 가 같은 집합에 속하는지 판별하는 문제)
{
    기본 원리: 주어진 노드 수만큼의 리스트를 생성하여 리스트에 본인의 루트 노드의 번호를 넣어 같은 집합에 속하는지 알아낸다.

    간단한 구현 방법: 노드 수만큼의 리스트 생성(트리 구조) -> 처음에는 본인의 루트 노드 값을 본인으로 설정([5] = {1,2,3,4,5}) 이후, 들어오는 정보에 따라서

    union 연산을 진행하여 리스트의 값을 갱신시킨다.

    union 연산 : 들어오는 2개 노드의 부모 노드를 확인 하여 두 부모 노드중 더 큰 부모 노드를 갖은 노드의 부모 노드 값을 작은 부모 노드로 변경해주는 연산

    find 연산 : 현재 들어온 노드의 부모 노드를 재귀적으로 탐색해주는 연산
}

2. 사이클 판별(서로소 집합 이용)
{
    기본 원리: A-B-C 가 존재하는 경우 A-B 의 부모 노드가 A 이고 A-C의 부모 노드가 A인 경우 B-C의 부모 노드가 동시에 A를 만족하기 때문에 사이클이 발생한 것을 알 수 있다.

    방법: union, find 연산을 이용하여 리스트를 생성하면서 각 노드의 부모 노드가 같은 경우 사이클이 발생한 것을 알 수 있다.
}

3. 크루스칼 알고리즘(신장 트리 : 모든 노드 포함 but, 사이클 X)
{
    기본 원리: 그리디 알고리즘(사이의 값을 기준으로 오름차순 정렬하여 작은 값 부터 연결 시작 -> 사이클 발생 시, 제외)

    방법: union_find 연산을 적절히 활용하여 같은 집합 내에 존재하지 않으며 모든 노드(N)가 연결(N-1)됐는지 확인하여 값을 도출
}

4. 위상 정렬(큐를 이용한 트리 구성 - 방향성이 존재하는 경우(순서 존재))
{
    기본 원리: 진입 차수(본인을 가르키고 있는 간선의 수)가 0인 노드를 큐에 집어넣고 노드에서 진행 가능한 노드로 이동하며 이동 노드에 대한 진입 차수를 1씩 차감한다.

    그렇게 계속하여 진행 중, 진입 차수가 0이 되는 노드는 큐에 집어넣고 동작을 반복한다. 

    방법 : 큐를 이용하여 push, pop을 이용해 시작점에서 도착점 까지의 경로를 탐색할 수 있다.
}