문제 
{
   철수는 온라인으로 컴퓨터공학강의를 듣고 있다.

    이때 각 온라인강의는 선수강의가 있을 수 있는데, 선수 강의가 있는 강의는 선수 강의를 먼저. 들어야만 해당강의를 들을 수 있다.

    예를들어 '알고리즘’ 강의의 선수 강의로 '자료구조'가 존재한다면, ‘자료구조를 들은 이후에 ‘알고리즘' 강의를 들을 수 있다.

    철수는 총 N개의 강의를 듣고자 한다. 모든 강의는 1번부터 N번까지의 번호를 가진다.

    또한 동시에 여러 개의 강의를 들을 수 있다고 가정한다.

    예를 들어 N=3일 때, 3번강의의 선수 강의로 1번과 2번강의가 있고, 1번과 2번강의는 선수강의가 없다고 가정하자.

    그리고 각 강의에 대하여 강의 시간이 다음과 같다고 가정하자.

    1번 강의: 30시간

    2번 강의: 20시간

    3번 강의: 40시간

    이 경우 1번 강의를 수강하기까지의 최소 시간은 30시간, 2번 강의를 수강하기까지의 최소 시간은 20시간, 3번 강의를 수강하기까지의 최소 시간은 70시간이다.

    철수가 듣고자 하는 N개의 강의 정보가 주어졌을 때, N개의 강의에 대하여 수강하기까지 걸리는 최소 시간을 각각 출력하는 프로그램을 작성하시오.
}

입력 조건
{
    첫째줄에 철수가 듣고자 하는 강의의 수 N(1≤N≤500)이 주어진다.

    다음 N개의 줄에는 각 강의의 강의 시간과 그. 강의를 듣기 위해 먼저 들어야하는 강의들의 번호가 자연수로 주어지며, 각. 자연수는 공백으로 구분한다. 
    
    이때 강의시간은 100,000이하의 자연수이다 .각 강의번호는 1부터 N까지로 구성되며. 각줄은 -1로 끝난다.
}
 
출력 조건
{
   N개의 강의에 대하여 수강하기까지 걸리는 최소 시간을 한 줄에 하나씩 출력한다
}
 

입력 예시1
{
    5
    10 -1
    10 1 -1
    4 1 -1
    4 3 1 -1
    3 3 -1
}
 

출력 예시1
{
    10
    20
    14
    18
    17
}


해결 방법
{
    기본적 아이디어 : 위상 정렬 사용

    선수 과목의 의미가 진입 차수와 같은 의미이기 때문에 위상 정렬을 이용하면 해결할 수 있다.

    특히, 답을 구하기 위해서는 위상 정렬을 통해 진입차수가 0인 노드를 넣고
    
    해당 노드의 수강 기간은 max를 이용하여 현재 들어있는 값 보다 큰 값을 넣는 것으로 갱신하면 된다.
    
    실제 해결 방법

    1. chasu[] 생성 : 각 노드의 진입차수 값을 갖고 있는 리스트

    2. answer[] 생성 : 각 index에 해당하는 값을 저장

    3. 합치기 명령이 들어올 경우 union 연산을 통해 2개의 root를 합쳐준다. 확인 명령이 들어온 경우 find 연산을 통해 현재 2 노드의 부모 노드가 같은지 확인한다.

}

보완할 점
{
    출력 결과를 출력 조건에 맞춰서 출력하는 것을 염두하자!
}